# 小试牛刀

首先，我们先使用 webpack 的命令行接口来学习 webpack 的基本打包过程。

## 创建一个模块化的 JavaScript 项目

先让我们使用 `CommonJs` 语法创建几个 javascript 模块：

**cats.js**

```javascript
var cats = ['dave', 'henry', 'martha'];
module.exports = cats;
```

**app.js (入口文件)**

```javascript
cats = require('./cats.js');
console.log(cats);
```

“入口点”是您的应用程序将启动的位置，并且 webpack 将开始跟踪模块之间的依赖关系。

**命令**

为 webpack 指定输入 (app.js) 和输出 (app.bundle.js)：

```sh
webpack ./app.js app.bundle.js
```

webpack 会读取并分析入口点和它的依赖库（包括间接依赖的库），然后将它们一起绑定到 `app.bundle.js` 。

![img](https://dtinth.github.io/webpack-docs-images/usage/how-it-works.png)

现在，你的 bundle 已经可以运行了。运行以下命令看看结果吧。

```sh
node app.bundle.js
```

# 趁热打铁

webpack 是一个非常灵活的模块化工具。它提供了很多高级功能，但并非所有功能都通过命令行方式。为了获得webpack 的全部功能，我们需要创建一个“配置文件”。

## 项目结构

在真实的 webpack 项目中，一般会将源文件根据目录来进行结构化的打包。

例如：将源文件放在 `src` 目录；将产生的打包文件放在 `bin` 目录。

最后的项目结构会像下面这样：

![img](https://raw.githubusercontent.com/dtinth/webpack-docs-images/2459637650502958669ea6b11bf49dc0b3b083ae/usage/project-structure.png)

> 而应用 webpack 的项目往往会有不同的项目结构。有些项目使用 `app` 代替 `src`。有些项目使用 `dist` 或 `build` 代替 `bin`。 含有测试代码的项目通常使用 `test` 、`tests` 、 `spec` 、`specs` 或将测试文件直接放在 source 目录下。

1. 创建 `bin` 和 `src` 目录。

   ```sh
   mkdir bin
   mkdir src
   ```

2. 移动源文件到 `src` 目录。

   ```sh
   mv app.js cats.js src
   ```

3. 初始化npm项目。

   ```sh
   npm init # (answer the questions)
   ```

4. 安装webpack。

   ```sh
   npm install --save-dev webpack
   ```

## 配置文件

随着项目增长和配置的复杂化，继续使用命令行方式来配置 webpack 就显得不明智了。

1. 创建 `webpack.config.js`:

   ```javascript
   module.exports = {
       entry: './src/app.js',
       output: {
           path: './bin',
           filename: 'app.bundle.js'
       }
   };
   ```

   > 一个 webpack 配置文件是一个 CommonJS 式的模块。因此，你可以在这里运行任何代码，只要一个配置对象被导出这个模块。

2. 有了配置文件后，你可以简化命令如下：

   ```sh
   webpack
   ```

   > webpack 会读取配置文件，构建 bundle， 并将内容存入  `bin/app.bundle.js` 。如果你检查webpack 的输出文件，你会发现源文件的内容都被包含在内。
   >

3. 运行下面命令看看结果吧：

   ```sh
   node bin/app.bundle.js
   ```

> 你也可以通过 npm 来 require 模块，没有额外的配置。
>

## 使用加载器

webpack 本身只支持 JavaScript 模块，但大多数人将使用 ES2015，CoffeeScript，TypeScript 等转译器。它们可以通过使用[加载器](https://webpack.github.io/docs/using-loaders.html)在 webpack 中使用。

加载器是 webpack 用来将其他模块（以另一种语言编写）加载到JavaScript（webpack理解的）中的特殊模块。例如，[`babel-loader`](https://github.com/babel/babel-loader) 使用Babel加载ES2015文件

![img](https://dtinth.github.io/webpack-docs-images/usage/babel-loader.png)

[`json-loader`](https://github.com/webpack/json-loader) 加载JSON文件（只需通过预先加入module.exports =将其转换为CommonJs模块）。

![img](https://dtinth.github.io/webpack-docs-images/usage/json-loader.png)

加载器可以链式调用，并且有时候你也需要将加载以链式方式组合在一起。
例如； [`yaml-loader`](https://github.com/okonet/yaml-loader) 只将 YAML 转换为 JSON。因此，您还需要使用 json-loader 进一步转换来使用。

![img](https://dtinth.github.io/webpack-docs-images/usage/yaml-loader.png)

### 例：使用 `babel-loader` 转译 ES2015

在这个例子中，我们要告诉 webpack 通过 [Babel](https://babeljs.io/) 运行我们的源文件，这样我们便可以使用ES2015的功能。

1. 安装 Babel 和 presets

   ```sh
   npm install --save-dev babel-core babel-preset-es2015
   ```

2. 安装 `babel-loader`

   ```sh
   npm install --save-dev babel-loader
   ```

3. 配置 Babel 以通过添加 `.babelrc` 来使用这些预设

   ```javascript
   { "presets": [ "es2015" ] }
   ```

4. 修改 `webpack.config.js` ，使用 `babel-loader` 来处理所有的 "*.js" 文件。

   ```javascript
   module.exports = {
       entry: './src/app.js',
       output: {
           path: './bin',
           filename: 'app.bundle.js',
       },
       module: {
           loaders: [{
               test: /\.js$/,
               exclude: /node_modules/,
               loader: 'babel-loader'
           }]
       }
   }
   ```

   > 我们在这里排除 `node_modules` 目录，否则所有外部库也将通过 Babel 转译，大大拖慢编译速度。

5. 安装你要使用的库 (比如：jQuery)

   ```sh
   npm install --save jquery babel-polyfill
   ```

   > We are using `--save` instead of `--save-dev` this time, as these libraries will be used in runtime. We also use `babel-polyfill` so that ES2015 APIs are available in older browsers.

6. 编辑 `src/app.js`:

   ```javascript
   import 'babel-polyfill';
   import cats from './cats';
   import $ from 'jquery';

   $('<h1>Cats</h1>').appendTo('body');
   const ul = $('<ul></ul>').appendTo('body');
   for (const cat of cats) {
       $('<li></li>').text(cat).appendTo(ul);
   }
   ```

7. 使用 webpack 命令执行打包模块操作：

   ```sh
    webpack
   ```

8. 添加 `index.html` ，现在你可以在浏览器中访问了

   ```html
   <!DOCTYPE html>
   <html>
       <head>
           <meta charset="utf-8">
       </head>
       <body>
           <script src="bin/app.bundle.js" charset="utf-8"></script>
       </body>
   </html>
   ```

当你在浏览器中打开 `index.html` ，你会看到下图中的内容。

![img](https://dtinth.github.io/webpack-docs-images/usage/cats.png)

有 [各种各样的加载器](https://webpack.github.io/docs/list-of-loaders.html) 提供给你，让你去处理你的 app bundle 中的文件，包括 css 样式文件和图片。

## 使用插件

通常，您需要在工作流程中对 bundle 进行一些额外的处理。一个例子是：压缩你的文件，以便客户端可以更快地加载它。这可以通过 [插件](https://webpack.github.io/docs/using-plugins.html) 来完成。我们将添加 uglify 插件到我们的配置：

```javascript
const webpack = require('webpack');

module.exports = {
    entry: './src/app.js',
    output: {
        path: './bin',
        filename: 'app.bundle.js',
    },
    module: {
        loaders: [{
            test: /\.js?$/,
            exclude: /node_modules/,
            loader: 'babel-loader',
        }]
    },
    plugins: [
        new webpack.optimize.UglifyJsPlugin({
            compress: {
                warnings: false,
            },
            output: {
                comments: false,
            },
        }),
    ]
}
```

Uglify 插件包含在 webpack 中，所以你不需要添加额外的模块，但并非总是如此。您可以编写自己的 [自定义插件](https://webpack.github.io/docs/how-to-write-a-plugin.html)。对于这个构建，uglify插件将包大小从1618字节削减到308字节。

# 引申阅读

- 参考 [CLI](http://webpack.github.io/docs/cli.html) 了解命令行接口
- 参考 [node.js API](http://webpack.github.io/docs/node.js-api.html) 了解 node.js 接口
- 参考 [Configuration](http://webpack.github.io/docs/configuration.html) 了解配置选项